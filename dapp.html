<script src='https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js'></script>

<script>
const network = 'rinkeby'
const ERC721ADDRESS = '0x50De9438e554E7512277BF9F06D44465adF405D3'
const ERC721ABI = [
{
anonymous: false,
inputs: [
{
indexed: false,
internalType: "uint256",
name: "old",
type: "uint256"
},
{
indexed: false,
internalType: "uint256",
name: "current",
type: "uint256"
}
],
name: "BTCETHPriceUpdated",
type: "event"
},
{
anonymous: false,
inputs: [
{
indexed: true,
internalType: "address",
name: "previousOwner",
type: "address"
},
{
indexed: true,
internalType: "address",
name: "newOwner",
type: "address"
}
],
name: "OwnershipTransferred",
type: "event"
},
{
anonymous: false,
inputs: [
{
indexed: true,
internalType: "address",
name: "from",
type: "address"
},
{
indexed: true,
internalType: "address",
name: "to",
type: "address"
},
{
indexed: true,
internalType: "uint256",
name: "tokenId",
type: "uint256"
}
],
name: "Transfer",
type: "event"
},
{
inputs: [
{
internalType: "address",
name: "owner",
type: "address"
}
],
name: "balanceOf",
outputs: [
{
internalType: "uint256",
name: "",
type: "uint256"
}
],
stateMutability: "view",
type: "function"
},
{
anonymous: false,
inputs: [
{
indexed: false,
internalType: "uint256",
name: "old",
type: "uint256"
},
{
indexed: false,
internalType: "uint256",
name: "current",
type: "uint256"
}
],
name: "BTCETHPriceUpdated",
type: "event"
},
{
inputs: [ ],
name: "getBitcoinPriceInWei",
outputs: [
{
internalType: "uint256",
name: "",
type: "uint256"
}
],
stateMutability: "view",
type: "function"
},
{
inputs: [ ],
name: "getPrice",
outputs: [
{
internalType: "uint256",
name: "",
type: "uint256"
}
],
stateMutability: "view",
type: "function"
},
{
inputs: [ ],
name: "maxSupply",
outputs: [
{
internalType: "uint256",
name: "",
type: "uint256"
}
],
stateMutability: "view",
type: "function"
},
{
inputs: [ ],
name: "publicSaleStart_timestampInS",
outputs: [
{
internalType: "uint256",
name: "",
type: "uint256"
}
],
stateMutability: "view",
type: "function"
},
{
inputs: [ ],
name: "purchase",
outputs: [ ],
stateMutability: "payable",
type: "function"
},
{
inputs: [
{
internalType: "address",
name: "from",
type: "address"
},
{
internalType: "address",
name: "to",
type: "address"
},
{
internalType: "uint256",
name: "tokenId",
type: "uint256"
}
],
name: "safeTransferFrom",
outputs: [ ],
stateMutability: "nonpayable",
type: "function"
},
{
inputs: [
{
internalType: "address",
name: "from",
type: "address"
},
{
internalType: "address",
name: "to",
type: "address"
},
{
internalType: "uint256",
name: "tokenId",
type: "uint256"
},
{
internalType: "bytes",
name: "_data",
type: "bytes"
}
],
name: "safeTransferFrom",
outputs: [ ],
stateMutability: "nonpayable",
type: "function"
},
{
inputs: [
{
internalType: "uint256",
name: "tokenId",
type: "uint256"
}
],
name: "tokenURI",
outputs: [
{
internalType: "string",
name: "",
type: "string"
}
],
stateMutability: "view",
type: "function"
},
{
inputs: [ ],
name: "totalSupply",
outputs: [
{
internalType: "uint256",
name: "",
type: "uint256"
}
],
stateMutability: "view",
type: "function"
}
]

</script>

<script>
console.log('Script started')

const ethSymbol = 'Œû'
const btcSymbol = '‚Çø'

const walletButton = document.querySelector('#walletButton')
const balanceLabel = document.querySelector('#balanceLabel')
const ethPriceLabel = document.querySelector('#ethPriceLabel')
const btcPriceLabel = document.querySelector('#btcPriceLabel')
const pizzasLabel = document.querySelector('#pizzasLabel')
const buyButton = document.querySelector('#buyButton')
const contractLabel = document.querySelector('#contractLabel')
const txLabel = document.querySelector('#txLabel')

balanceLabel.innerHTML = '--' + ' ' + ethSymbol
ethPriceLabel.innerHTML = '--' + ' ' + ethSymbol
btcPriceLabel.innerHTML = '--' + ' ' + btcSymbol
pizzasLabel.innerHTML = '--'
contractLabel.innerHTML = "Contract Address: <p> <a href='https://" + network + ".etherscan.io/address/" +
  ERC721ADDRESS + "' target='_blank'> " + ERC721ADDRESS + " </a>"

// Placeholder values
let maxSupply = 10000
let totalSupply = 0
let buyPrice = 0.0001
let walletAddress = 0
let addresses = 0
let btcPrice = 30
let metamaskInstalled = false
let Erc721Instance

const numberWithCommas = (x) => x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
const isMobile = () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)

const updateValues = () => {
  if (!Erc721Instance) return

  Erc721Instance.methods.getPrice().call()
    .then((amount) => {
      buyPrice = web3.utils.fromWei(amount)
      const roundPrice = parseFloat(buyPrice).toFixed(4)
      console.log('Price: ', roundPrice)

      btcPriceLabel.innerHTML = roundPrice + ' ' + ethSymbol
    })
    .catch((_) => {
      console.log('getPrice failed')
    })

  Erc721Instance.methods.maxSupply().call()
    .then((amount) => {
      maxSupply = amount

      console.log('maxSupply: ', amount)

      pizzasLabel.innerHTML = numberWithCommas(maxSupply - totalSupply)
    })
    .catch((_) => {
      console.log('maxSupply failed')
    })

  Erc721Instance.methods.totalSupply().call()
    .then((amount) => {
      totalSupply = amount

      console.log('totalSupply: ', amount)

      pizzasLabel.innerHTML = numberWithCommas(maxSupply - totalSupply)
    })
    .catch((_) => {
      console.log('totalSupply failed')
    })

  Erc721Instance.methods.getBitcoinPriceInWei().call()
    .then((amount) => {
      btcPrice = web3.utils.fromWei(amount)

      console.log('BtcPrice: ', btcPrice)

      const roundPrice2 = parseFloat(buyPrice/btcPrice).toFixed(4)

      ethPriceLabel.innerHTML = roundPrice2 + ' ' + btcSymbol
    })
    .catch((_) => {
      console.log('getBtcPrice failed')
    })
}

const handleUser = () => {
  web3.eth.getAccounts()
    .then(async (accounts) => {
      addresses = accounts

      console.log('accounts: ', accounts)

      if (!accounts.length) {
        console.log('User is logged out')
      } else {
        console.log('User is logged in')

        await updateBalance()
      }
    }).catch((err) => {
    console.log('Error fetching accounts: ', err)
  })
}

const connectToContract = () => {
  console.log('App started')

  Erc721Instance = new web3.eth.Contract(ERC721ABI,ERC721ADDRESS)

  Erc721Instance.events.Transfer((err, e) => { console.log(e) })
    .on('data', (e) =>{
      console.log('event: ', e)

      updateValues()
      //console.log('eventTokenId: ', event['returnedValues']['tokenId']) // TO-DO: get pizza # from here
    })
    .on('changed', (i) => {
      console.log('changed: ', i)
    })
    .on('error on Transfer', console.error)

  updateValues()
  handleUser()
}

const promptMetamask = () => {
  window.ethereum.enable()
    .then(async () => {
      await updateBalance()
    }).catch((err) => {
    console.log(err)
  })
}

const triggerPurchase = () => {
  if (!Erc721Instance) return

  txLabel.innerHTML = 'Waiting for confirmation'
  let txHash = 0

  Erc721Instance.methods.getPrice().call()
    .then((amount) => {
      console.log('priceWei: ', amount)

      Erc721Instance.methods.purchase().send({from: walletAddress, value: (1.15 * amount)})
        .on('transactionHash', (hash) => {
          console.log('transactionHash: ', hash)
          txHash = hash
        })
        .on('receipt', (receipt) => {
          console.log('receipt: ', receipt)

          txLabel.innerHTML = "Transaction confirmed, enjoy your üçï! <p> " +
            "<a href='https://" + network + ".etherscan.io/tx/" +
            txHash + "' target='_blank'> Transaction link </a>"

          updateValues()
        })
        .on('error', (err, receipt) => {
          console.log('Transaction failed: ', err, 'br/', receipt)

          txLabel.innerHTML = 'Something went wrong, try again!'
        })
    })
    .catch((_) => {
      console.log('getPrice failed')

      txLabel.innerHTML = 'Something went wrong, try again!'
    })
}

const updateBalance = async () => {
  walletAddress = (await web3.eth.getAccounts())[0]

  console.log('Wallet address: ', walletAddress)

  const walletBalance = await web3.eth.getBalance(walletAddress)
  const balance = web3.utils.fromWei(walletBalance)
  const roundedBalance = parseFloat(balance).toFixed(4)

  console.log('ETH balance: ', roundedBalance)

  balanceLabel.innerHTML = roundedBalance + ' ' + ethSymbol
}

const buyButtonHandler = () => {
  console.log('Buy button pressed')

  handleUser()

  if (!addresses.length) {
    promptMetamask()
  } else {
    triggerPurchase()
  }
}

const walletButtonHandler = () => {
  console.log('Wallet button pressed')

  if (metamaskInstalled) {
    promptMetamask()
  } else {
    window.open('https://www.metamask.io')
  }
}

const startApp = () => {
  console.log('Loading window')

  walletButton.addEventListener('click', walletButtonHandler)
  buyButton.addEventListener('click', buyButtonHandler)
}

const initWeb3 = () => {
  let connected = false

  if (window.ethereum) {
    console.log('Window.ethereum exists')

    window.web3 = new Web3(window.ethereum)

    connected = true
  } else if (window.web3) {
    console.log('Window.web3 exists')

    window.web3 = new Web3(window.web3.currentProvider)

    connected = true
  } else if (isMobile) {
    console.log('Mobile initiated')

    connected = true
  } else {
    console.log('web3 not found')
  }

  return {
    connected,
  }
}

const onLoadHandler = () => {
  let counter = 0;
  const maxAttempts = 3; // We're only going to check this many times.

  // Add an event listener for when 'web3' is successfully injected.
  window.addEventListener('web3Injected', startApp, { once: true });

  const intervalId = setInterval(() => {
    const { connected } = initWeb3();

    counter++;

    // If we tried more than the 'maxAttempt' we stop checking.
    if (counter > maxAttempts) {
      console.log(`- Could not find web3 after ${counter - 1} attempts.`);

      window.alert('Browser might not be compatible. Try Chrome and MetaMask!')
      txLabel.innerHTML = 'Try Chrome and MetaMask!'

      // Clean up the event listener.
      window.removeEventListener('web3Injected', main, { once: true });

      // Clean up interval.
      return clearInterval(intervalId);
    }

    console.log(`${counter}: Checking for web3...`);

    // Check if 'web3' is injected in the page.
    if (connected) {
      console.log('- web3 was successfully injected!');

      metamaskInstalled = true

      // Clean up interval.
      clearInterval(intervalId);

      // Dispatch 'web3Injected' event to trigger the 'main' function.
      dispatchEvent(new Event('web3Injected'));
    }
  }, 1000); // We're going to check ever 1000 milliseconds (or every 1 seconds).
}

window.addEventListener('load', onLoadHandler, { once: true })
</script>
